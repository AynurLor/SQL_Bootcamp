# День 09


## Упражнение 00 

Мы хотим быть сильнее с данными и не хотим потерять ни одного события изменений. Давайте реализуем функцию аудита для входящих изменений INSERT. 
Пожалуйста, создайте таблицу `person_audit` с такой же структурой, как у таблицы person, но добавьте несколько дополнительных изменений. Посмотрите на таблицу ниже с описаниями для каждого столбца.

| Колонка | Тип | Описание |
| ------ | ------ | ------ |
| created | timestamp with time zone | временная метка, когда было создано новое событие.  Значение по умолчанию - текущая метка времени и NOT NULL |
| type_event | char(1) | возможные значения I (вставить), D (удалить), U (обновить). Значение по умолчанию - 'I'. NOT NULL. Добавить проверочное ограничение `ch_type_event` с возможными значениями 'I', 'U' и 'D' | | row_id |bigint.
| row_id |bigint | копия person.id. NOT NULL |
| name |varchar | копия person.name (без каких-либо ограничений) | |
| age |integer | копия person.age (без ограничений)| |
| gender |varchar | копия person.gender (без каких-либо ограничений) | |
| адрес |varchar | копия person.address (без ограничений)|

На самом деле, давайте создадим функцию триггера базы данных с именем `fnc_trg_person_insert_audit`, которая должна обрабатывать DML-трафик `INSERT` и создавать копию новой строки в таблице person_audit.

Просто подсказка, если вы хотите реализовать триггер PostgreSQL (пожалуйста, прочитайте об этом в документации PostgreSQL), вам нужно создать 2 объекта: Database Trigger Function и Database Trigger. 

Итак, определите триггер базы данных с именем `trg_person_insert_audit` со следующими параметрами
- триггер с опцией "ДЛЯ КАЖДОЙ СТРОКИ
- триггер с опцией "AFTER INSERT"
- триггер вызывает функцию триггера fnc_trg_person_insert_audit


## Упражнение 01

Давайте продолжим реализацию нашего шаблона аудита для таблицы person. Просто определите триггер `trg_person_update_audit` и соответствующую функцию триггера `fnc_trg_person_update_audit` для обработки всего трафика `UPDATE` для таблицы person. Мы должны сохранить OLD состояния всех значений атрибутов.


## Упражнение 02 

Наконец, нам нужно обработать заявления `DELETE` и сделать копию состояния OLD для всех значений атрибутов. Пожалуйста, создайте триггер `trg_person_delete_audit` и соответствующую функцию триггера `fnc_trg_person_delete_audit`. 

Когда вы будете готовы, пожалуйста, примените следующий SQL оператор.

`DELETE FROM person WHERE id = 10;`


## Упражнение 03

На самом деле, для одной таблицы `person` существует 3 триггера. Давайте объединим всю нашу логику в один главный триггер с именем `trg_person_audit` и новой соответствующей триггерной функцией `fnc_trg_person_audit`.

Другими словами, весь трафик DML (`INSERT`, `UPDATE`, `DELETE`) должен обрабатываться из одного функционального блока. Пожалуйста, явно определите отдельный блок IF-ELSE для каждого события (I, U, D)!

Кроме того, пожалуйста, выполните следующие действия.
- удалить 3 старых триггера из таблицы персон.
- удалить 3 старые триггерные функции
- сделать `TRUNCATE` (или `DELETE`) всех строк в нашей таблице `person_audit`.


## Упражнение 04

Как вы помните, мы создали 2 представления базы данных для разделения данных из таблиц персон по признаку пола. 
Пожалуйста, определите 2 SQL-функции (пожалуйста, обратите внимание, не pl/pgsql-функции) с именами
- `fnc_persons_female` (должна возвращать лиц женского пола)
- `fnc_persons_male` (должна возвращать лиц мужского пола).

Чтобы проверить себя и вызвать функцию, вы можете сделать оператор, как показано ниже (удивительно! вы можете работать с функцией как с виртуальной таблицей!). 


## Упражнение 05

Похоже, что 2 функции из упражнения 04 требуют более общего подхода. Пожалуйста, перед дальнейшими действиями удалите эти функции из базы данных. 
Напишите общую SQL-функцию (пожалуйста, обратите внимание, не pl/pgsql-функцию) с именем `fnc_persons`. Эта функция должна иметь `IN` параметр pgender со значением по умолчанию = 'female'. 

Чтобы проверить себя и вызвать функцию, вы можете сделать оператор, как показано ниже (вау! Вы можете работать с функцией как с виртуальной таблицей, но с большей гибкостью!). 


## Упражнение 06

Пожалуйста, создайте pl/pgsql функцию `fnc_person_visits_and_eats_on_date` на основе SQL оператора, которая находит названия пиццерий, которые человек (`IN` параметр pperson со значением по умолчанию 'Дмитрий') посетил и купил пиццу дешевле заданной суммы в рублях (`IN` параметр pprice со значением по умолчанию 500) в определенную дату (`IN` параметр pdate со значением по умолчанию 8 января 2022 года). 


## Упражнение 07

Напишите, пожалуйста, функцию SQL или pl/pgsql `func_minimum` (на ваше усмотрение), входным параметром которой является массив чисел, а функция должна возвращать минимальное значение. 


## Упражнение 08

Пожалуйста, напишите SQL или pl/pgsql функцию `fnc_fibonacci` (на ваше усмотрение), которая имеет входной параметр pstop с типом integer (по умолчанию 10), а выходным параметром функции является таблица со всеми числами Фибоначчи меньше pstop.
