# День 06 

## Упражнение 00

Давайте расширим нашу модель данных, чтобы включить новую бизнес-функцию.
Каждый человек хочет видеть персональную скидку, а каждый бизнес хочет быть ближе для клиентов.

Пожалуйста, подумайте о персональных скидках для людей с одной стороны и о ресторанах-пиццериях с другой. Необходимо создать новую реляционную таблицу (пожалуйста, задайте имя `person_discounts`) со следующими правилами.
- установить атрибут id как первичный ключ (пожалуйста, посмотрите на столбец id в существующих таблицах и выберите тот же тип данных)
- установите для атрибутов person_id и pizzeria_id внешние ключи для соответствующих таблиц (типы данных должны быть такими же, как для столбцов id в соответствующих родительских таблицах)
- задайте явные имена для ограничений внешних ключей по шаблону fk_{имя_таблицы}_{имя_колонки}, например `fk_person_discounts_person_id`.
- добавьте атрибут discount для хранения значения скидки в процентах. Помните, что значение скидки может быть числом с плавающей точкой (пожалуйста, используйте тип данных `numeric`). Поэтому, пожалуйста, выберите соответствующий тип данных, чтобы покрыть эту возможность.


## Упражнение 01

Фактически, мы создали структуру для хранения наших скидок и готовы идти дальше и заполнить таблицу `person_discounts` новыми записями.

Итак, есть таблица `person_order`, которая хранит историю заказов человека. Напишите оператор DML (`INSERT INTO ... SELECT ...`), который вставляет новые записи в таблицу `person_discounts` на основе следующих правил.
- берем агрегированное состояние по столбцам person_id и pizzeria_id 
- вычисляет значение персональной скидки по следующему псевдокоду:

    `если "количество заказов" = 1, то
        "скидка" = 10,5 
    else if "amount of orders" = 2 then 
        "скидка" = 22
    else 
        "скидка" = 30`

- для создания первичного ключа для таблицы person_discounts используйте SQL конструкцию ниже (эта конструкция находится в области WINDOW FUNCTION SQL).
    
    `... ROW_NUMBER( ) OVER ( ) AS id ...`.



## Упражнение 02

Напишите, пожалуйста, SQL-запрос, который возвращает заказы с фактической ценой и ценой с примененной скидкой для каждого человека в соответствующем ресторане пиццерии и сортирует их по имени человека и названию пиццы. 


## Упражнение 03

На самом деле, нам нужно улучшить согласованность данных с одной стороны и настроить производительность с другой стороны. Пожалуйста, создайте многоколоночный уникальный индекс (с именем `idx_person_discounts_unique`), который предотвращает дублирование парных значений идентификаторов персоны и пиццерии.

После создания нового индекса, пожалуйста, предоставьте любой простой SQL-запрос, который показывает доказательство использования индекса (с помощью `EXPLAIN ANALYZE`).



## Упражнение 04

Пожалуйста, добавьте следующие правила ограничений для существующих столбцов таблицы `person_discounts`.
- столбец person_id не должен быть NULL (используйте имя ограничения `ch_nn_person_id`)
- столбец pizzeria_id не должен быть NULL (используйте имя ограничения `ch_nn_pizzeria_id`)
- столбец скидка не должен быть NULL (использовать имя ограничения `ch_nn_discount`)
- столбец скидки должен быть равен 0 процентов по умолчанию
- колонка скидки должна быть в диапазоне значений от 0 до 100 (используйте имя ограничения `ch_range_discount`)


## Упражнение 05

Для удовлетворения политик управления данными необходимо добавить комментарии для таблицы и столбцов таблицы. Давайте применим эту политику для таблицы `person_discounts`. Пожалуйста, добавьте английские или русские комментарии (на ваше усмотрение), которые объясняют, что является бизнес-целью таблицы и всех включенных в нее атрибутов. 


## Упражнение 06 

Давайте создадим последовательность базы данных с именем `seq_person_discounts` (начиная с 1 значения) и установим значение по умолчанию для атрибута id таблицы `person_discounts`, чтобы каждый раз автоматически брать значение из `seq_person_discounts`. 
Пожалуйста, имейте в виду, что ваш следующий номер последовательности равен 1, в этом случае установите фактическое значение для последовательности базы данных по формуле "количество строк в таблице person_discounts" + 1. В противном случае вы получите ошибки о нарушении ограничения Primary Key.
